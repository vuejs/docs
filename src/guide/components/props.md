# Входные параметры {#props}

> Эта страница предполагает, что вы уже прочитали [Основы компонентов](/guide/essentials/component-basics). Сначала прочитайте это, если вы новичок в работе с компонентами.

<div class="options-api">
  <VueSchoolLink href="https://vueschool.io/lessons/vue-3-reusable-components-with-props" title="Бесплатный урок про входные параметры"/>
</div>

## Объявление входных параметров {#props-declaration}

Компоненты Vue требуют явного объявления входных параметров, чтобы Vue знал, какие внешние входные параметры, переданны компоненту, следует рассматривать как обычные атрибуты (которые будут рассмотрены в [отдельном разделе](/guide/components/attrs)).

<div class="composition-api">

В SFC использующих `<script setup>`, входные параметры могут быть объявлены с помощью макроса `defineProps()`:

```vue
<script setup>
const props = defineProps(['foo'])

console.log(props.foo)
</script>
```

В компонентах не имеющих`<script setup>`, входные параметры объявляются с помощью [`props`](/api/options-state.html#props):

```js
export default {
  props: ['foo'],
  setup(props) {
    // setup() получает входной параметр в качестве первого аргумента.
    console.log(props.foo)
  }
}
```

Обратите внимание, что аргумент, передаваемый в `defineProps()`, совпадает со значением, предоставляемым `props`: один и тот же API _props_ разделяется между двумя стилями декларации.

</div>

<div class="options-api">

Входные параметры объявляются с помощью опции [`props`](/api/options-state.html#props):

```js
export default {
  props: ['foo'],
  created() {
    // входной парметр доступен в `this`
    console.log(this.foo)
  }
}
```

</div>

В дополнение к объявлению входных параметров с использованием массива строк, мы также можем использовать объектный синтаксис:

<div class="options-api">

```js
export default {
  props: {
    title: String,
    likes: Number
  }
}
```

</div>
<div class="composition-api">

```js
// С использованием <script setup>
defineProps({
  title: String,
  likes: Number
})
```

```js
// Без использования <script setup>
export default {
  props: {
    title: String,
    likes: Number
  }
}
```

</div>

Для каждого свойства в синтаксисе объявления объекта ключом является имя входного параметра, а значением должна быть функция-конструктор ожидаемого типа.

Это не только документирует ваш компонент, но и предупредит других разработчиков, использующих ваш компонент, в консоли браузера, если они передадут неверный тип. Более подробно [валидацию входных параметров](#prop-validation) мы рассмотрим далее на этой странице.

<div class="options-api">

См. также: [Типизирование входных параметров](/guide/typescript/options-api.html#typing-component-props) <sup class="vt-badge ts" />

</div>

<div class="composition-api">

Если вы используете TypeScript с `<script setup>`, можно также объявлять входные параметры с помощью аннотаций чистого типа:

```vue
<script setup lang="ts">
defineProps<{
  title?: string
  likes?: number
}>()
</script>
```

Подробнее: [Типизирование входных параметров](/guide/typescript/composition-api.html#typing-component-props) <sup class="vt-badge ts" />

</div>

## Детали передачи входных параметров {#prop-passing-details}

### Именование входных параметров {#prop-name-casing}

Мы объявляем длинные имена свойств, используя camelCase, поскольку это позволяет избежать необходимости использовать кавычки при использовании их в качестве ключей свойств, а также позволяет нам ссылаться на них непосредственно в выражениях шаблона, поскольку они являются валидными идентификаторами JavaScript:

<div class="composition-api">

```js
defineProps({
  greetingMessage: String
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    greetingMessage: String
  }
}
```

</div>

```vue-html
<span>{{ greetingMessage }}</span>
```

Технически, вы также можете использовать camelCase при передаче входных параметров дочернему компоненту (за исключением [шаблонов DOM](/guide/essentials/component-basics.html#dom-template-parsing-caveats)). Тем не менее, общепринятым является использование kebab-case во всех случаях для согласования с атрибутами HTML:

```vue-html
<MyComponent greeting-message="hello" />
```

Мы используем [PascalCase для тегов компонентов](/guide/components/registration.html#component-name-casing), когда это возможно, потому что это улучшает читаемость шаблона, отличая компоненты Vue от собственных элементов. Однако практическая польза от использования camelCase при передаче входных параметров не так велика, поэтому мы предпочитаем следовать соглашениям каждого языка.

### Статические и динамические входные параметры {#static-vs-dynamic-props}

До сих пор вы встречали, что входные параметры передаются как статические значения, например:

```vue-html
<BlogPost title="Как изучить Vue" />
```

Вы также встречали входные параметры, присваивающие динамическое значение с помощью  `v-bind` или сокращения `:`, например:

```vue-html
<!-- Динамически присваиваем значение переменной -->
<BlogPost :title="post.title" />

<!-- Динамически присваиваем значение комплексного выражения -->
<BlogPost :title="post.title + ' by ' + post.author.name" />
```

### Передача значений различных типов {#passing-different-value-types}

В двух приведенных выше примерах мы передаем строковые значения, но _любой_ тип значения может быть передан во входной параметр.

#### Числа {#number}

```vue-html
<!-- Несмотря на то, что `42` статическое значение, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.    -->
<BlogPost :likes="42" />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :likes="post.likes" />
```

#### Булевы значения {#boolean}

```vue-html
<!-- Указание входного параметра без значения будет означать `true`. -->
<BlogPost is-published />

<!-- Несмотря на то, что `false` статическое значение, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.      -->
<BlogPost :is-published="false" />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :is-published="post.isPublished" />
```

#### Массивы {#array}

```vue-html
<!-- Несмотря на то, что указан статический массив, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<BlogPost :comment-ids="[234, 266, 273]" />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :comment-ids="post.commentIds" />
```

#### Объекты {#object}

```vue-html
<!-- Несмотря на то, что указан статический объект, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<BlogPost
  :author="{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }"
 />

<!-- Динамическое присвоение значения переменной. -->
<BlogPost :author="post.author" />
```

### Передача нескольких свойств с помощью объекта {#binding-multiple-properties-using-an-object}

Если хотите передать все свойства объекта в качестве входных параметров, то можно использовать [`v-bind` без аргументов](/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes) (`v-bind` вместо `:prop-name`). Например, для объекта `post`:

<div class="options-api">

```js
export default {
  data() {
    return {
      post: {
        id: 1,
        title: 'Как изучить Vue'
      }
    }
  }
}
```

</div>
<div class="composition-api">

```js
const post = {
  id: 1,
  title: 'Как изучить Vue'
}
```

</div>

Следующий шаблон:

```vue-html
<BlogPost v-bind="post" />
```

Будет аналогичен такой записи:

```vue-html
<BlogPost :id="post.id" :title="post.title" />
```

## Однонаправленный поток данных {#one-way-data-flow}

Все входные параметры образуют **одностороннюю привязку** между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Это предотвращает случайное изменение дочерними компонентами родительского состояния, что может затруднить понимание потока данных приложения.

Кроме того, каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены актуальными значениями. Это означает, что **не должны** пытаться изменять входной параметр внутри дочернего компонента. Если это сделать, Vue отобразит предупреждение в консоли.

<div class="composition-api">

```js
const props = defineProps(['foo'])

// ❌ предупреждение, входные параметры доступны только для чтения!
props.foo = 'bar'
```

</div>
<div class="options-api">

```js
export default {
  props: ['foo'],
  created() {
    // ❌ предупреждение, входные параметры доступны только для чтения!
    this.foo = 'bar'
  }
}
```

</div>

Обычно встречаются два случая, когда возникает соблазн изменять входной параметр:

1. **Входной параметр используется для передачи начального значения; дочерний компонент хочет использовать его как локальное свойство данных в дальнейшем.** В этом случае лучше всего определить локальное свойство в данных, которое использует значение входного параметра в качестве начального:

   <div class="composition-api">

   ```js
   const props = defineProps(['initialCounter'])

   // counter использует только props.initialCounter в качестве начального значения;
   // он не будет получать будущие обновления входного параметра.
   const counter = ref(props.initialCounter)
   ```

   </div>
   <div class="options-api">

   ```js
   export default {
     props: ['initialCounter'],
     data() {
       return {
         // counter использует только this.initialCounter в качестве начального значения;
         // он не будет получать будущие обновления входного параметра.
         counter: this.initialCounter
       }
     }
   }
   ```

   </div>

2. **Входной параметр передаётся как необработанное значение, которое необходимо преобразовать.** В таком случае лучше всего объявить вычисляемое свойство с использованием входного параметра:

   <div class="composition-api">

   ```js
   const props = defineProps(['size'])

   // вычисляемое свойство автоматически обновится при изменении входного параметра
   const normalizedSize = computed(() => props.size.trim().toLowerCase())
   ```

   </div>
   <div class="options-api">

   ```js
   export default {
     props: ['size'],
     computed: {
       // вычисляемое свойство автоматически обновится при изменении входного параметра
       normalizedSize() {
         return this.size.trim().toLowerCase()
       }
     }
   }
   ```

   </div>

### Мутация объектов / массивов из входных параметров {#mutating-object-array-props}

Когда объекты и массивы передаются как входные параметры, дочерний компонент не может изменить привязку входного параметра, но он  **сможет** изменить вложенные свойства объекта или массива. Это связано с тем, что в JavaScript объекты и массивы передаются по ссылке, и предотвращение таких мутаций для Vue неоправданно дорого.

Основным недостатком таких мутаций является то, что они позволяют дочернему компоненту влиять на родительское состояние способом, который не очевиден для родительского компонента, что может затруднить анализ потока данных в будущем. Для лучшей практики следует избегать таких мутаций, если только родительский и дочерний элементы не тесно связаны по замыслу. В большинстве случаев дочерний компонент должен [выдать событие](/guide/components/events.html), чтобы позволить родительскому элементу выполнить мутацию.

## Валидация входных параметров {#prop-validation}

Компоненты могут указывать требования к своим входным параметрам, такие как определение типа, которые уже видели выше. Если эти требования не выполнены — Vue предупредит сообщением в JavaScript-консоли браузера. Это особенно полезно при разработке компонента, который предназначен для использования другими.

Чтобы указать валидации входного параметра, вы можете предоставить в <span class="composition-api">`defineProps()`</span><span class="options-api">опцию `props`</span>, объект с валидациями для проверки значения, вместо массива строк. Например:

<div class="composition-api">

```js
defineProps({
  // Базовая проверка типов
  //  (`null` и `undefined` проходят проверку для любого типа)
  propA: Number,
  // Несколько допустимых типов
  propB: [String, Number],
  // Обязательное значение строкового типа
  propC: {
    type: String,
    required: true
  },
  // Число со значением по умолчанию
  propD: {
    type: Number,
    default: 100
  },
  // Объект со значением по умолчанию
  propE: {
    type: Object,
    // Для объектов или массивов значения по умолчанию
    // должны возвращаться из функции. Функция получает необработанные
    // входные параметры, полученные компонентом в качестве аргумента.
    default(rawProps) {
      return { message: 'привет' }
    }
  },
  // Пользовательская функция для валидации
  propF: {
    validator(value) {
      // Значение должно соответствовать одной из этих строк
      return ['success', 'warning', 'danger'].includes(value)
    }
  },
  // Функция с значением по умолчанию
  propG: {
    type: Function,
    // В отличие от объекта или массива по умолчанию, это не фабричная функция — это функция, служащая в качестве значения по умолчанию
    default() {
      return 'Функция по умолчанию'
    }
  }
})
```

:::tip Совет
Код внутри аргумента `defineProps()` **не может получить доступ к другим переменным, объявленным в `<script setup>`** поскольку при компиляции все выражение перемещается во внешнюю область видимости функции.
:::

</div>
<div class="options-api">

```js
export default {
  props: {
    // Базовая проверка типов
    //  (`null` и `undefined` проходят проверку для любого типа)
    propA: Number,
    // Несколько допустимых типов
    propB: [String, Number],
    // Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // Число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // Объект со значением по умолчанию
    propE: {
      type: Object,
      // Для объектов или массивов значения по умолчанию
      // должны возвращаться из функции. Функция получает необработанные
      // входные параметры, полученные компонентом в качестве аргумента.
      default(rawProps) {
        return { message: 'hello' }
      }
    },
    // Пользовательская функция для валидации
    propF: {
      validator(value) {
        // Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].includes(value)
      }
    },
    // Функция с значением по умолчанию
    propG: {
      type: Function,
      // В отличие от объекта или массива по умолчанию, это не фабричная функция — это функция, служащая в качестве значения по умолчанию
      default() {
        return 'Функция по умолчанию'
      }
    }
  }
}
```

</div>

Дополнительные сведения:

- Все входные параметры по умолчанию являются необязательными, если не указано `required: true`.

- Отсутствующий необязательный входной параметр, отличный от `Boolean` будет иметь значение `undefined`.

- Отсутствующий входной параметр `Boolean` будет приведен к `false`. Вы можете изменить это, задав для него значение `по умолчанию`. Например: `default: undefined`, чтобы он вел себя как не булево значение.

- Если указано значение `по умолчанию`, оно будет использоваться, если разрешенное значение входного параметра `undefined` - это включает в себя как отсутствие входного параметра, так и явное `undefined` значение.

Когда проверка свойства завершается неудачей, Vue выдает консольное предупреждение (если используется сборка для разработки).

<div class="composition-api">

Если вы используете [объявления свойств на основе типов](/api/sfc-script-setup.html#typescript-only-features) <sup class="vt-badge ts" />, Vue сделает все возможное, чтобы скомпилировать аннотации типов в эквивалентные объявления свойств во время выполнения. Например, `defineProps<{ msg: string }>` будет скомпилирован в `{ msg: { type: String, required: true }}`.

</div>
<div class="options-api">

:::tip Примечание
Обратите внимание, что входные параметры проверяются **до** создания экземпляра компонента, поэтому свойства экземпляра (например `data`, `computed`, и т.д.)  не будут доступны в функциях `default` и `validator`.
:::

</div>

### Проверка типа во время выполнения {#runtime-type-checks}

Значением `type` может быть одним из следующих собственных конструкторов:

- `String`
- `Number`
- `Boolean`
- `Array`
- `Object`
- `Date`
- `Function`
- `Symbol`

Кроме того, `type` может быть пользовательским классом или функцией конструктора, и утверждение будет сделано с помощью проверки `instanceof`. Например, дан следующий класс:

```js
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
}
```

Вы можете использовать его как тип входного параметра:

<div class="composition-api">

```js
defineProps({
  author: Person
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    author: Person
  }
}
```

</div>

Vue будет использовать `instanceof Person` для проверки того, действительно ли значение входного параметра `author` является экземпляром класса `Person`.

## Булево преобразование {#boolean-casting}

Входные параметры с типом `Boolean` имеют специальные правила приведения, чтобы имитировать поведение собственных булевых атрибутов. Дан  `<MyComponent>` со следующим объявлением:

<div class="composition-api">

```js
defineProps({
  disabled: Boolean
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    disabled: Boolean
  }
}
```

</div>

Компонент можно использовать следующим образом:

```vue-html
<!-- эквивалентно :disabled="true" -->
<MyComponent disabled />

<!-- эквивалентно :disabled="false" -->
<MyComponent />
```

Когда входной параметр объявлен так, что допускает несколько типов, например:

<div class="composition-api">

```js
defineProps({
  disabled: [Boolean, Number]
})
```

</div>
<div class="options-api">

```js
export default {
  props: {
    disabled: [Boolean, Number]
  }
}
```

</div>

Правила приведения для `Boolean` будут применяться независимо от порядка перечисления типа.
